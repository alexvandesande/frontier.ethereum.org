extends layout

block content
  div.main-tutorial.scrollme.intro
    div.scrollme.row.introduction.animateme(data-when="span", data-from="0", data-to="1", data-opacity="0.2", data-translatey="200")
      div.animateme(data-when="span", data-from="0", data-to="1", data-translatey="150")
        h1 Welcome to the frontier

  div.main-content
    div.container
      div.row
        div.col-md-12
          div#install-terms
            h2 Before installing ethereum
            ul
              li #[b Frontier] is a curated #[b.text-danger testnet], it is not the 'main release' of Ethereum, but rather an #[b.text-danger initial beta prerelease]
              li We fully expect instability and consensus flaws in the client, some of which may be exploitable
              li As curators, we fully reserve the right to ignore blocks at our discretion
              li As curators, from a final block that we solely determine, we will preserve all non-contract (i.e. code-less) account balances above the value of 1 ETH into the Homestead Genesis block


            div.terms-checkbox.pull-left
              label(for="understand")
                input#understand(type="checkbox", value="true")
                | I understand, let me proceed to install

            //- 
              a#show-install.pull-left.btn.btn-danger.disabled
                //- i.fa.fa-code
                | #[nbsp] show install instructions

          div#install-info.hidden
            h2 Install ethereum frontier release

            pre ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Ethereum/install/master/install)"

            p Paste the above one-liner in your terminal for an automated install script. This script will detect your OS and will attempt to install the ethereum CLI. Please click the button below if you'd like to see a step by step description of the installer script.

            a#show-source.btn.btn-warning
              //- i.fa.fa-code
              | #[nbsp] view source

            div#shell-source.hidden
              pre
                code(class="bash")
                  include ./../bin/install.sh

              a#hide-source.btn.btn-warning
                //- i.fa.fa-code
                | #[nbsp] hide source

      div.clearfix
        br
        br

      div.row
        div.col-md-12
          //-
            h2 Next steps
            p If the install was successful you can now run ethereum using the following command line in the Terminal prompt:

            pre ethereum

            p Run #[code ethereum -help] for more information about command line options or check our #[a(target="_blank", href="https://github.com/ethereum/go-ethereum/wiki") documentation].

      div.clearfix
        br
        br

  div.main-tutorial.part0
    div.container   
      include ./includes/tldr.jade 

  div.main-tutorial.part1
    div.container
      div.row
        div.col-md-12.tutorial.scrollme
          ul#toc.animateme(data-when="enter", data-from="1", data-to="0.75", data-opacity="0", data-translatex="100")


          img(src='images/welcome-sign.png').pull-right.animateme(data-when="enter", data-from="0.6", data-to="0.2", data-opacity="0")

          div.animateme(data-when="enter", data-from="0.8", data-to="0.4", data-opacity="0", data-translatey="50")
            h2#part1 Gething started
            h3 Setting yourself up to the adventure
          
          div.clearfix
            br
            br
          
          div.animateme(data-when="enter", data-from="0.8", data-to="0.4", data-opacity="0")
            p The Frontier is the first live release of the Ethereum network. As such you are entering uncharted territory and you are invited to test the grounds and explore. There is a lot of danger, there may still be undiscovered traps, there may be ravaging bands of pirates waiting to attack you, but there also is vast room for opportunities.

            p In order to navigate the Frontier, you’ll need to use the command line. If you are not comfortable using it, we strongly advise you to step back, watch from a distance for a while and wait until more user friendly tools are made available. Remember, there are no safety nets and for everything you do here, you are mostly on your own.

            

          h3 Hitching up your wagon.


          p The Frontier tool is called Geth (the old english third person singular conjugation of “to go”. Quite appropriate given geth is written in Go). In order to get it, open your command line tool (if you are unsure how to do this, consider waiting for a more user friendly release) and paste the command below. 

          code ruby -e "$(curl -fsSL https://raw.githubusercontent.com/cubedro/frontier.ethereum.org/master/bin/install.rb)"
          
          p Or, alternatively


          code ruby -e "$(curl -fsSL https://raw.githubusercontent.com/cubedro/frontier.ethereum.org/master/bin/install.rb)"


          p Paste the above one-liner in your terminal for an automated install script. This script will detect your OS and will attempt to install the ethereum CLI. Please click the button below if you'd like to see a step by step description of the installer script.


          p Geth is a multipurpose command line tool that runs a full Ethereum node implemented in Go. It offers three interfaces: the command line subcommands and options [link], a JSON-RPC server and an interactive console. For the purposes of this guide, we will focus on the Console, a javascript environment that contains all the main features you probably want. Type the code below on your terminal


          code geth console 2>>geth.log


          p You are ready to start. The 2>>geth.log creates a text file with the output of your console. On a linux machine or Mac OS you can run one terminal with the geth console and a second one with the logging output by opening a new terminal and typing: tty
          
          p The output will be something like: /dev/pts/13 (or on Mac /dev/tty002). Then in your main terminal type: geth console 2>> /dev/pts/13  This will allow you to monitor your node without cluttering your console.
           
          p The geth console has history that persists between sessions. You can navigate your command history by using the up and down arrow keys.


          p Tip: sometimes you might not need to connect to the live public network, you can instead choose to create your own private testnet. This is very useful if you don't need to test external contracts and want just to test the technology, because you won't have to compete with other miners and will easily generate a lot of test ether to play around (replace 12345 with any number):
          
          code geth —networkid 12345 console


          p If you use a private testnet, it may be a good idea to start with a 'fresh' blockchain, and not the real blockchain. Otherwise, in order to successfully mine a block, you'll need to mine against the difficulty of the last block present in your local copy of the blockchain - which may take several hours. This is done via the `--datadir` parameter: 


          code geth --networkid=-123 --datadir=~/.ethereum_experiment console`




          h3 Starting down the trail.




          p In order to do most actions in Ethereum you need ether, and to get it, you will need to generate an address (see here for detailed documentation on managing your accounts). Type: 


          code admin.newAccount()


          p You’ll be asked for a passphrase. Choose one wisely and you will be prompted to type it twice. Do NOT forget this passphrase, otherwise it will not be possible to recover any funds you may have on your account. You’ve been warned!


          p Tip: Typing “admin” by itself will bring up a list of sub commands used to administer your geth installation.


          p The Following command generates an address and associates it with your local machine. You can create multiple accounts by executing the same command again. Go on, try it:


          code admin.newAccount()


          p By convention we call the first account you create your primary account. You can see all your accounts with the command:


          code eth.accounts


          p Notice that it outputs a Javascript array. It’s because all commands on the console are actually in javascript, so you can create variables and daisychain functions. You can also write any “eth” function as “web3.eth” since it’s actually part of the main “web3” object.


          p Try this for example:


          code var primaryAccount = eth.accounts[0]


          p You now have a variable called primaryAccount that you can use in other calls, like this:


          code eth.getBalance(primaryAccount)


          p Already feeling comfortable? Time to get some ether. There are three different ways:


          h4 1. Get ether from someone else


          p That is by far the easiest way to get ether, but you need to know someone who is willing to give you a hand. If you have such a friend, then type:


          code eth.accounts[0]


          p Copy the address and send it to them hoping to receive some love through the ether. If you don't know anyone who can provide it for you, you can use a faucet, which hand out test ether for free. Try the Zerogox or EtherParty faucets.  If the faucets are not online for some reason, you can also try asking directly to the community on IRC. 


          h4 2. Mining ether


          p Since you are one of the first pioneers, it might be possible to acquire ether by mining. You can start your mining operation by typing


          code admin.miner.start()


          p Before you can really find blocks your computer needs to go through a process called “building a DAG”. The DAG (which stands for “Directed Acyclic Graph”) is a large block of data that is required for mining, intended to prevent ASIC appliances (which stands for “Application Specific Integrated Circuits”) from being mass manufactured for mining ethereum.  It is intended to protect pioneers like yourself so that you will only ever need your home computer to mine.. The DAG should take about 10 minutes to generate and as soon as it finishes it will start mining automatically. If at any point you want to see what’s going on, you can type


          code admin.miner.hashrate() 


          p This gives you an idea of how much work your computer is doing per second. Now head to the Network Stats Page and take a look at the Difficulty. Divide that number by your current hashrate and that will give you an estimate, in seconds, of how long you can expect to wait until you mine a block and get some ether. This is an overestimate because it does not take in consideration the number and rewards for uncle blocks. You can use this code snippet to do this automatically:


          code Math.floor(10 * eth.getBlock("latest").difficulty /( 60 * admin.miner.hashrate()))/10 + " Minutes"




          p If you have successfully mined a block you will see a message like this in the logfile:


          code  🔨 Mined block #12345


          p Your coinbase is the account where your mining reward is sent, by default it is the primary account. In order to check your earnings, you can display your coinbase balance:


          code web3.fromWei(eth.getBalance(eth.coinbase), "ether")


          p Note: the mining rewards in the frontier network are only 10% of what they’ll be when the Homestead phase begins. Frontier should be always considered a test network for the network.


          p Things to do: If you are serious about mining, then you can also: read more about mining with ‘geth’, understand the current proof of work and why it is ASIC resistant, read up about proof of stake, or start your GPU mining operation.  Read the Mining Documentation or check out the ethereum mining guide on our forums. 


          h4 3. Importing from the presale


          p Before you decide to import your presale ether wallet, please remember that Frontier is a test network. It’s dangerous, potentially full of bugs and is prone to instability. While all account balances above 1 ether will be moved over to homestead when it launches, the money in contracts will not. There are many potential mishaps, money can be lost, stolen or locked into a broken contract. We strongly advise you to only move funds that you are willing to risk. If you still want to go forward, then importing your presale wallet is very easy (if you remember your password that is). First you have to quit the console by pressing control+c and getting back to the terminal application. 


          p Now get your presale file on your computer and find the path to it. Finally, type:


          code geth wallet import /path/to/my/presale.wallet

          p This will prompt for your password and imports your ether presale account. It can be used non-interactively with the --password option taking a passwordfile as argument containing the wallet password in cleartext.



  div.main-tutorial.part2
    div.container


        h2#part2 Basics
        h3 Sending your first transaction


        p There are two types of accounts in ethereum:

        ol.note
          li normal accounts, which hold only ether that can be moved with a private key and
          li contract addresses, which hold ether controlled by its own internal code. Let’s focus on the former first. 


        p And similarly, your transactions are also of two types: transactions sent to normal accounts are ether transfers, while the rest is communication with smart contracts, 


        p Before you send your first ether transfer you need a friend to send your ether to. If you don’t have any, you can also create as many new accounts as you want, following the steps discussed above and simply move your funds between accounts you own. After you’ve done that, run this:  


        var sender = eth.accounts[0];
        var receiver = eth.accounts[1];
        var amount = web3.toWei(0.01, "ether");


        p The first two lines set local variables with account numbers for easier access later.. Change the sender and receiver address as much as you like. If you are adding an address instead, put it in between quotes like ‘0xffd25e388bf07765e6d7a00d6ae83fa750460c7e'. The third line converts the token units as required by the network..


        p Although there are many names for ether denominations we will use only two: “ether” and “wei”. The wei is the minimum atomic unit of ether, and is what is used on the system level. Most day to day transactions will be done with ether, which is equivalent to one quintillion wei, or a 1 followed by 18 zeros. So before sending any transactions it’s very important to convert it to wei, and for that, use the web3.toWei function. (If you are dealing with small amounts of ether, it might be useful to use “finney”, which is a shorthand for a thousandth of an ether, but in most cases ether will suffice).


        p After having set the variables above, send the transaction with:


        eth.sendTransaction({from:sender, to:receiver, value: amount})


        p After waiting a few seconds, the transaction should be complete. To check the balance of an account, you simply type:


        
        code  eth.getBalance(eth.accounts[0]);

        p Tip: if you want to check the balance of all your accounts at once, use this JavaScript code snippet:


        p This code will run in each of your accounts and print its balance in ether.


        code  function checkAllBalances() { 
          |   var i =0; 
          |   eth.accounts.forEach( function(e){
          |     console.log("  eth.accounts["+i+"]: " +  e + " \tbalance: " + web3.fromWei(eth.getBalance(e), "ether") + " ether"); 
          |     i++; 
          |   })
          | }; 


        p Once you executed the line above, all you need to check your whole balance is:


        code checkAllBalances();


        p Try it yourself:  tweak this javascript function to make it show another unit, like “finney”.  


        p Learn more: Read the transactions documentation


        h3 Easier addresses: the Name Registrar
        p All accounts are referenced in the network by their public address. But addresses are long, difficult to write down, hard to memorize and immutable. The last one is specially important if you want to be able to generate fresh accounts in your name, or upgrade the code of your contract. In order to solve this, there is a default name registrar contract which is used to associate the long addresses with short, human-friendly names.


        p Names have to use only alphanumeric characters and, cannot contain blank spaces. In future releases the name registrar will likely implement a bidding process to prevent name squatting but for now, it's a first come first served based. So as long as no one else registered the name, you can claim it.


        p First, select your name:

        p.code var myName = "bob"
        
        Then, check the availability of your name:
        
        code registrar.addr(myName)

        p If that function returns "0x00..", you can claim it to yourself:

        code registrar.reserve.sendTransaction(myName, {from: eth.accounts[0]});
        
        p Wait for the previous transaction to be picked up. Wait up to thirty seconds and then try:

        code registrar.owner(myName)

        p If it returns your address, it means you own that name and are able to set your chosen name to any address you want:

        code registrar.setAddress.sendTransaction(myName, eth.accounts[1], true,{from: eth.accounts[0]});
        You can send a transaction to anyone by name instead of account simply by typing 


        eth.sendTransaction({from: eth.accounts[0], to: registrar.addr("bob"), value: web3.toWei(1, "ether")})

        p.note Tip: don't mistake registrar.addr for registrar.owner. The first is to which address that name is pointed at: anyone can point a name to anywhere else, just like anyone can forward a link to google.com, but only the owner of the name can change and update the link. You can set both to be the same address.
  

  div.main-tutorial.part3
    div.container


        h2#part3  Contracts 
        strong (or how to create your own personal country)


        p   Now that you mastered the basics on how to get started and how to send ether, it's time to get your hands dirty in what really makes ethereum stand out of the crowd: smart contracts. Smart contracts are pieces of code that live on the blockchain and execute commands exactly how they were told to. They can read other contracts, take decisions, send ether and execute other contracts. Contracts will exist and run as long as the whole network exists, and will only stop if they run out of gas or if they were programmed to self destruct.


        p   What can you do with contracts? You can do almost anything really, but for this guide let's do something simple: you will start your new country.


        p   Your country won't be very powerful compared to most: it will hold no land, have no military and hold no assets other than those that exist on the blockchain. All it's citizens will be voluntary and it is unable to coerce other people by force. 


        p   But what it can do is to gather support around a united cause. You will get funds through a crowdfunding that, if successful, will supply a radically transparent and democratic organization that will only obey its own citizens, will never swerve away from its constitution and cannot be censored or shut down. And all that in less than 300 lines of code.


        p   So let's start now.
        
        p.note   Important: Frontier is considered a test network. All contracts might be wiped when the project transitions to the next phase, and all ether they contain will be lost. Only send small amounts of funds to contracts, unless are okay losing them.





        h3 You first citizen 
          strong The Greeter


        p full documentation: https://github.com/ethereum/go-ethereum/wiki/Contracts-and-Transactions


        p Now that you’ve mastered the basics of Ethereum, let’s move into your first serious contract. It’s a big open territory and sometimes you might feel lonely, so our first order of business will be to create a little automatic companion to greet you whenever you feel lonely. We’ll call him the “Greeter”.

        code
          | contract greeter {
          |     // Declare variable admin which will store an address
          |     address public admin;
          | 
          | 
          |     // this function is executed at initialization 
          |     // and sets the owner of the contract
          |     function greeter() {
          |         admin = msg.sender;
          |     }
          | 
          | 
          |     // main function
          |     function greet(bytes32 input) returns (bytes32) {
          |         if (input == "") {  return "Hello, World"; }
          |         return input; 
          |     }
          |    
          |    // Function to recover the funds on the contract
          |     function kill() {
          |         if (msg.sender == admin) {
          |             suicide(admin);
          |         }
          |     }
          | }


        p As you can see, the Greeter is an intelligent digital entity that lives on the blockchain and is able to have conversations with anyone who interacts with it, based on its input. It might not be a talker, but it’s a great listener.


        p Before you are able to upload it to the network, you need two things: the compiled code, and the Application Binary Interface, which is a sort of user guide on how to interact with the contract.


        p The first you can get by using a compiler. You should have a solidity compiler built in on your geth console. To test it, use this command:


        code eth.getCompilers()


        p If you have it installed, it should output something like this:


        code ['Solidity' ]


        p If instead the command returns an error, then read the documentation on how to install a compiler, use Aleth zero or use the  online solidity compiler. 


        p If you have Geth Solidity Compiler installed,  you need now reformat by removing spaces so it fits into a string variable (there are some online tools that will do this):


        code var greeterSource = 'contract greeter { address admin; function greeter() { admin = msg.sender; } function greet(bytes32 input) returns (bytes32) { if (input == "") { return "Hello, World"; } return input; } function kill() { if (msg.sender == admin) { suicide(admin); } }}'


        p Once you successfully executed the above, compile it and publish to the network using the following commands:


        p.code
          | var greeterCompiled = eth.compile.solidity(greeterSource)
          | var greeterAddress = eth.sendTransaction({data: greeterCompiled.greeter.code, from: eth.accounts[0], gas:1000000, gasPrice: web3.toWei(0.001, "finney")}); 


        p You will probably be asked for the password you picked in the beginning. You are choosing from which account will pay for the transaction. Depending on the current gas price, expect that this contract to cost approximately 0.5 ether.


        p You can take a look to see if your transaction is on the list of pending transactions waiting to be picked up:


        code eth.pendingTransactions()


        p Wait a minute for your transaction to be picked up and then type:


        code eth.getCode(greeterAddress)


        p This should return the code of your contract. If it returns “0x”, it means that your transaction has not been picked up yet. Wait a little bit more. If it still hasn't, check if you are connected to the network
        net.peerCount


        p If you have more than 0 peers and it takes more than a minute or two for your transaction to be mined, your gas price might have been too low. Go back to that command above and try playing around with the gas price or gas amount. Go too up and you might reach gas limit of the block, go too low and the price might be too low, or the gas insufficient for the transaction to be picked up.


        p After your code has been accepted, eth.getCode(codeAddress) will return a long string of numbers. If that’s the case, congratulations, your little Greeter is live! If the contract is created again (by performing another eth.sendTransaction), it will be published to a new address. 


        p Now that your contract is live on the network, anyone can interact with it by instantiating a local copy. But in order to do that, your computer needs to know how to interact with it, which is what the Application Binary Interface (ABI) is for. To generate a contract from ABI you have to do this:


        code greeterContract = eth.contract(greeterCompiled.greeter.info.abiDefinition)


        p Tip: if the solidity compiler isn't properly installed in your machine, you can get the ABI from the online compiler . To do so, use the code below carefully replacing greeterCompiled.greeter.info.abiDefinition  with the abi from your compiler.


        p After having created a local copy of the object, this is how you actually instantiate that object from a live contract address:


        code greeterInstance = greeterContract.at(greeterAddress)


        p Alternatively, those two lines could be written together in a single call:


        code greeterInstance = eth.contract(greeterCompiled.greeter.info.abiDefinition).at(greeterAddress)


        p Your instance is ready. In order to call it, just type the following command in your terminal:


        code greeterInstance.greet.call("");


        p If your greeter returned “Hello World” then congratulations, you just created your first digital conversationalist bot!  Try again with: 


        code greeterInstance.greet.call("hi");




        p.note Cleaning up after yourself: You must be very excited to have your first contract live, but this excitement wears off sometimes, when the owners go on to write further contracts, leading to the unpleasant sight of abandoned contracts on the blockchain. In the future, blockchain rent might be implemented in order to increase the scalability of the blockchain but for now, be a good citizen and humanely put down your abandoned bots. The suicide is subsidized by the contract creation so it will cost much less than a usual transaction.


        code greeterInstance.kill.sendTransaction({from:eth.accounts[0], gasPrice: web3.toWei(0.001, "finney")})


        p Notice that every contract has to implement it's own kill clause. In this particular case only the account that created the contract can kill it. If you don't add any kill clause it could potentially live forever (or at least until the frontier contracts are all wiped) independently of you and any earthly borders, so before you put it live check what your local laws say about it, including any possible limitation on technology export, restrictions on speech and maybe future legislation on civil rights of sentient digital beings.




        p.note Try it yourself:  You can experiment changing its parameters to make it smarter. Challenge yourself to have it charge ether for its profound advice by adding the following function on the "greet". Here's a simple example on how to make the greeter into a joker by making it sell jokes*:


        code  if (input=="Who's there?") { 
          |   /* insert a joke here */
          | } else if (msg.value > 1000) { 
          |   /* a trillionth of an ether. It's a cheap joke. */
          |   return "Knock knock!"; 
          | }


        p Any balance your greeter is able to make will be forwarded to you on the kill call. 


        p  *Actually the blockchain is open source and anyone could read your joke for free, but has anyone ever laughed by reading source code?


        p Test it with others: anyone else running the geth console can interact with your contract by first instantiating it using this line of code:


        code greeterInstance = eth.contract([{constant:false,inputs:[],name:'kill',outputs:[],type:'function'},{constant:false,inputs:[{name:'input',type:'bytes32'}],name:'greet',outputs:[{name:'',type:'bytes32'}],type:'function'},{inputs:[],type:'constructor'} ]).at(greeterAddress);



        h3 Issue your own money: 
          strong Coin contract


        p Now let's create a coin for your country. Coins are much more interesting and useful than they seem, they are in essence just a tradeable token, but can become much more, depending on how you use them. It's value depends on it's use: a token can be used to control access (an entrance ticket), can be used for voting rights in an organization (a share), can be placeholders for an asset held by a third party (a certificate of ownership) or even be simply used as an exchange of value within a community (a currency). 


        p You could do all those things by creating a centralized server, but using an Ethereum token contract comes with some free qualities: for one, it's a decentralized service and tokens can be still exchanged even if the original service goes down for any reason. The code guarantees that no tokens will ever be created other than the ones set in the original code. Finally, by having each user hold it's own token, this eliminates the scenarios where one single server break in can result in the loss of funds from thousands of clients.


        p This is the code for the contract we're building:

        code  contract token { 
          |    mapping (address => uint) public balances;
          |        
          |    /* Initializes contract with 10 000 tokens to the creator of the contract */
          |    function token() {
          |        balances[msg.sender] = 10000;
          |    }
          |        
          |    /* Very simple trade function */
          |    function sendToken(address receiver, uint amount) returns(bool sufficient) {
          |        if (balances[msg.sender] < amount) return false;
          |        balances[msg.sender] -= amount;
          |        balances[receiver] += amount;
          |        return true;
          |    }
          |}


        p If you have ever programmed, you won't find it hard to understand what it does: it's a contract that generates 10 thousand tokens to the creator of the contract, and then allows anyone with a balance to send it to others. These tokens are the minimum tradeable unit and cannot be subdivided, but for the final users could be presented as a 100 units subdividable by 100 subunits, so owning a single token would represent having 0.01% of the total. If your application needs more fine grain atomic divisibility, then just increase the initial issuance amount.


        p In this example we declared the variable "balance" to be public, this will automatically create a function that checks any accounts balance.


        p So let's run it!


        code var tokenSource = 'contract token { mapping (address => uint) public balances; /* Initializes contract with 10 000 tokens to the creator of the contract */ function token() { balances[msg.sender] = 10000; } /* Very simple trade function */ function sendToken(address receiver, uint amount) returns(bool sufficient) { if (balances[msg.sender] < amount) return false; balances[msg.sender] -= amount; balances[receiver] += amount; return true; } }'


        p Now let’s set up the contract, just like we did in the previous section..
        
        code var tokenCompiled = eth.compile.solidity(tokenSource)
          | var tokenAddress = eth.sendTransaction({data: tokenCompiled.token.code, from: eth.accounts[0], gas:1000000, gasPrice: web3.toWei(0.001, "finney")}); 


        p Wait minute until and use the code below to test if your code has been deployed.


        code eth.pendingTransactions();


        code eth.getCode(tokenAddress)


        p And then 


        code tokenInstance = eth.contract(tokenCompiled.token.info.abiDefinition).at(tokenAddress)


        p You can check your own balance with:


        code tokenInstance.balances.call(eth.accounts[0])


        p It should have all the 10 000 tokens that were created once the contract was published. Since there p is not any other defined way for new coins to be issued, those are all that will ever exist. 


        p Now of course those tokens aren't very useful if you hoard them all, so in order to send them to someone else, use this command:
        
        code tokenInstance.sendToken.sendTransaction(eth.accounts[1], 1000, {from: eth.accounts[0]})


        p If a friend has registered a name on the registrar you can send it without knowing their address, doing this:


        code tokenInstance.sendToken.sendTransaction(registrar.addr("Alice"), 2000, {from: eth.accounts[0]})


        p The reason that the first command was .call() and the second is a .sendTransaction() is that the former is just a read operation and the latter is using gas to change the state of the blockchain, and as such, it needs to be set who is it coming from. Now, wait a minute and check both accounts balances:


        code tokenInstance.balances.call(eth.accounts[0])
          | tokenInstance.balances.call(eth.accounts[1])
          | tokenInstance.balances.call(registrar.addr("Alice"))




        p Try for yourself: You just created your own cryptocurrency! Right now this cryptocurrency is quite limited as there will only ever be 10,000 coins and all are controlled by the coin creator, but you can change that. You could for example reward ethereum miners, by creating a transaction that will reward who found the current block:


        code mapping (uint => address) miningReward;
          | function claimMiningReward() {
          |   if (miningReward[block.number] == 0) {
          |     balances[block.coinbase] += 1;
          |     miningReward[block.number] = block.coinbase;
          |   }
          | }


        p You could modify this to anything else: maybe reward someone who finds a solution for a new puzzle, wins a game of chess, install a solar panel—as long as that can be somehow translated to a contract. Or maybe you want to create a central bank for your personal country, so you can keep track of hours worked, favors owed or control of property. In that case you might want to add a function to allow the bank to remotely freeze funds and destroy tokens if needed.


        h4 Getting others to interact with your contract


        p The commands mentioned only work because you have tokenInstance instantiated on your local machine. If you send tokens to someone they won't be able to move them forward because they don't have the same object. In fact if you restart your console these objects will be deleted and the contracts you've been working on will be lost forever. So how do you instantiate the contract on a clean machine? 


        p There are two ways. Let's start with the quick and dirty, providing your friends with a reference to your contract’s ABI:


        code tokenInstance = eth.contract([{constant:false,inputs:[{name:'receiver',type:'address'},{name:'amount',type:'uint256'}],name:'sendToken',outputs:[{name:'sufficient',type:'bool'}],type:'function'},{type:'function',constant:true,inputs:[{name:'',type:'address'}],name:'balance',outputs:[{name:'',type:'uint256'}]},{inputs:[],type:'constructor'}]).at('0x4a4ce7844735c4b6fc66392b200ab6fe007cfca8')


        p Just replace the address at the end for your own token address, then anyone that uses this snippet will immediately be able to use your contract. Of course this will work only for this specific contract so let's analyze step by step and see how to improve this code so you'll be able to use it anywhere.


        p First, if you register a name, then you won't need the hard coded address in the end. Select a nice coin name for you and try to reserve for yourself.


        code var tokenName = "MyFirstCoin"
          | registrar.reserve.sendTransaction(tokenName, {from: eth.accounts[0]});
        
        p Wait for the previous transaction to be picked up and then set that name to point to your coin address:


        code registrar.setAddress.sendTransaction(tokenName, tokenAddress, true,{from: eth.accounts[0]});
        
        p Wait a little bit for that transaction to be picked up too and test it:
        registrar.addr("MyFirstCoin")


        p This should now return your token address, meaning that now the previous code to instantiate could use a name instead of an address.


        code tokenInstance = eth.contract([{constant:false,inputs:[{name:'receiver',type:'address'},{name:'amount',type:'uint256'}],name:'sendToken',outputs:[{name:'sufficient',type:'bool'}],type:'function'},{type:'function',constant:true,inputs:[{name:'',type:'address'}],name:'balance',outputs:[{name:'',type:'uint256'}]},{inputs:[],type:'constructor'}]).at(registrar.addr("MyFirstCoin"))


        p This also means that the owner of the coin can update the coin by pointing the registrar to the new contract. This would, of course, require the coin holders trust the owner set at  registrar.owner("MyFirstCoin")


        p The code is still long and not very friendly, and that's mostly because of the ABI that uses most of the contract code space. Ideally the only thing the user should need to know to access the contract would be it's name. In order to do that we have to register the abi somewhere also, which what the Contract Metadata Registry is for.


        p To  initiate the process, execute this:


        code admin.contractInfo.newRegistry(eth.accounts[0])


        p In the future Ethereum will have support for a pure hash-based content system to allow any data to be saved in the P2P network, but for now we'll have to create some files and upload them manually. First create a file on your system (e.g. in your desktop, if you're messy like me) and add its path like this:


        code var localFilePath = '/Users/yourusername/Desktop/abi.json'


        p Now use this line to write to that file and save its hash:


        code contentHash = admin.contractInfo.register(eth.accounts[0], tokenAddress, tokenCompiled.token, localFilePath)


        p You now have to put the .json file you just created somewhere publicly accessible. If you have an http server you can just drag into it, but you can also use a service like PasteBin or Gist. Create a new unlisted/private file, copy the content from the file you just created and save it. Then click the "raw" link and get the link like this:


        code var remoteFilePath = 'https://gist.githubusercontent.com/alexvandesande/ee0d34f5ac47937b6330/raw/6813c4e5eee9af33a1728565141ca4572530ffcd/abi.json'


        p Now finally you can register the ABI with:


        code admin.contractInfo.registerUrl(eth.accounts[0], contentHash, remoteFilePath)


        p Wait for the miners to pick it up and check if everything went well with:


        code admin.contractInfo.get(registrar.addr(tokenName)).AbiDefinition


        p This should return the ABI. If it doesn't, then double check the process and maybe try uploading your file to a different host. Now in order to instantiate the contract in any computer all one has to know is either its address or registered name.
        
        code var tokenAddress = registrar.addr("MyFirstCoin")
          | var tokenInstance = eth.contract(admin.contractInfo.get(tokenAddress).AbiDefinition).at(tokenAddress)


        h4 Future improvements, not yet implemented: 


        ul
          li Formal proofing is a way where the contract developer will be able to assert some invariant qualities of the contract, like the total cap of the coin.
          li Meta coin standard is a proposed standardization of function names for coin and token contracts, to allow them to be automatically added to other ethereum contract that utilizes trading, like exchanges or escrow.



        h3 Trustless fundraising: 
          strong the crowdfunder
        
        p Creating a country takes a lot of funds and collective effort. You could ask for donations, but donors prefer to give to projects they are more certain that will get traction and proper funding. This is an example where a crowdfunding would be ideal: you set up a goal and a deadline for reaching it. If you miss your goal, the donations are returned, therefore reducing the risk for donors. Since the code is open and auditable, there is no need for a centralized trusted platform and therefore the only fees everyone will pay are just the gas fees.


        p Since you already have your own internal currency, you can use that to help gather funds. In this crowdsale contract everyone who contribute will also get a proportional amount of the tokens you created. This can be used to as a proof of citizenship, as a share system or simply as a reward for their help as early pioneers.


        p Attention: All contracts could be wiped out at the end of Frontier. While balances on normal addresses will be transported to Homestead, balances in contracts, as well as addresses with less than 1 ether, will not. So use this crowdfunding contract for testing purposes and don't put any significant funds unless you know what you are doing.


        code contract token { mapping (address => uint) public balance; function token() {}  function sendToken(address receiver, uint amount) returns(bool sufficient) {  } }
          | contract CrowdSale {
          |  
          |  address public admin;
          |  address public beneficiary;
          |  uint public fundingGoal;
          |  uint public numFunders;
          |  uint public amountRaised;
          |  uint public deadline;
          |  uint public price;
          |  token public tokenReward;   
          |  mapping (uint => Funder) public funders;
          |  
          |  /* data structure to hold information about campaign contributors */
          |  struct Funder {
          |      address addr;
          |      uint amount;
          |  }
          |  
          |  /*  at initialization, setup the owner */
          |  function CrowdSale() {
          |  admin = msg.sender;
          |  }   
          |  
          | function setup(address _beneficiary, uint _fundingGoal, uint _duration, uint _price, address _reward) returns (bytes32 response){
          |     if (msg.sender == admin && !(beneficiary > 0 && fundingGoal > 0 && deadline > 0)) {
          |          beneficiary = _beneficiary;
          |          fundingGoal = _fundingGoal;
          |          deadline = now + _duration * 1 days;
          |          price = _price;
          |          tokenReward = token(_reward);
          |          
          |          return "campaign is set";
          |      } else if (msg.sender != admin) {
          |          return "not authorized";
          |      } else  {
          |          return "campaign cannot be changed";
          |      }
          |  }
          |  
          |  /* The function without name is the default function that is called whenever anyone sends funds to a contract */
          |  function () returns (bytes32 response) {
          |      Funder f = funders[numFunders++];
          |      f.addr = msg.sender;
          |      f.amount = msg.value;
          |      amountRaised += f.amount;
          |      tokenReward.sendToken(msg.sender, f.amount/price);
          |      
          |      return "thanks for your contribution";
          |  }
          |      
          |  /* checks if the goal or time limit has been reached and ends the campaign */
          |  function checkGoalReached() returns (bytes32 response) {
          |      if (amountRaised >= fundingGoal){
          |          uint i = 0; 
          |          beneficiary.send(amountRaised);
          |       suicide(beneficiary);
          |       return "Goal Reached!"; 
          |      }
          |      else if (deadline <= block.number){
          |          uint j = 0;
          |          uint n = numFunders;
          |          while (j <= n){
          |              funders[j].addr.send(funders[j].amount);
          |              funders[j].addr = 0;
          |              funders[j].amount = 0;
          |              j++;
          |          }
          |                   suicide(beneficiary);
          |          return "Deadline passed";
          |      }
          |      return "Not reached yet";
          |  }
          |}

        p You know the drill. Remove line breaks and copy the following commands on the terminal:


        code var crowdsaleSource = 'contract token { mapping (address => uint) public balance; function token() {}  function sendToken(address receiver, uint amount) returns(bool sufficient) {  } } contract CrowdSale { address public admin; address public beneficiary; uint public fundingGoal; uint public numFunders; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping (uint => Funder) public funders; /* data structure to hold information about campaign contributors */ struct Funder { address addr; uint amount; } /* at initialization, setup the owner */ function CrowdSale() { admin = msg.sender; } function setup(address _beneficiary, uint _fundingGoal, uint _duration, uint _price, address _reward) returns (bytes32 response){ if (msg.sender == admin && !(beneficiary > 0 && fundingGoal > 0 && deadline > 0)) { beneficiary = _beneficiary; fundingGoal = _fundingGoal; deadline = now + _duration * 1 days; price = _price; tokenReward = token(_reward); return "campaign is set"; } else if (msg.sender != admin) { return "not authorized"; } else { return "campaign cannot be changed"; } } /* The function without name is the default function that is called whenever anyone sends funds to a cntract */ function () returns (bytes32 response) { Funder f = funders[numFunders++]; f.addr = msg.sender; f.amount = msg.value; amountRaised += f.amount; tokenReward.sendToken(msg.sender, f.amount/price); return "thanks for your contribution"; } /* checks if the goal or time limit has been reached and ends the campaign */ function checkGoalReached() returns (bytes32 response) { if (amountRaised >= fundingGoal){ uint i = 0; beneficiary.send(amountRaised); suicide(beneficiary); return "Goal Reached!"; } else if (deadline <= block.number){ uint j = 0; uint n = numFunders; while (j <= n){ funders[j].addr.send(funders[j].amount); funders[j].addr = 0; funders[j].amount = 0; j++; } suicide(beneficiary); return "Deadline passed"; } return "Not reached yet"; } }'
          | var crowdsaleCompiled = eth.compile.solidity(crowdsaleSource);
          | var crowdsaleAddress = eth.sendTransaction({data: crowdsaleCompiled.CrowdSale.code, from: eth.accounts[0], gas:1000000, gasPrice: web3.toWei(0.001,"finney")}); 


        p Wait minute until and use the code below to test if your code has been deployed.


        code eth.pendingTransactions();
          | eth.getCode(crowdsaleAddress)


        p If it has, then do these commands to instantiate it locally.
        
        code crowdsaleInstance = web3.eth.contract(crowdsaleCompiled.CrowdSale.info.abiDefinition).at(crowdsaleAddress)

        p  Your first step now is to set the contract up. You can only do it once and it needs to come from the same account that created the contract in the first place.

        code var beneficiary = eth.accounts[1];          // create an account for this
          | var fundingGoal = web3.toWei(100, "ether"); // raises a 100 ether
          | var duration = 7;                 // number of days the campaign will last
          | var price = web3.toWei(0.02, "ether"); // the price of the tokens, in ether
          | var reward = registrar.addr("MyFirstCoin");         // the token contract address.
        
        p On Beneficiary put the new address that will receive the raised funds. The funding goal is the amount of ether to be raised. Deadline is measured in blocktimes which average 12 seconds, so the default is about 4 weeks. The price is tricky: but just change the number 2 for the amount of tokens the contributors will receive for each ether donated. Finally reward should be the address of the token contract you created in the last section.


        p In this example you are sending to the crowdsale fund 50% of all the tokens that ever existed, in exchange for 100 ether. Decide those parameters very carefully as they will play a very important role on the next part of our guide.


        code crowdsaleInstance.setup.sendTransaction(beneficiary, fundingGoal, deadline, price, reward, {from: eth.accounts[0], gas: 150000, gasPrice:web3.toWei(0.001, "finney")});


        p Dont forget to fund your newly created contract with the necessary tokens so it can pay back the contributors!


        code tokenInstance.sendToken.sendTransaction(crowdsaleAddress, 5000,{from: eth.accounts[0]})


        p After the transaction is picked, you can check the amount of tokens the crowdsale address has, and all other variables this way:


        code tokenInstance.balance.call(crowdsaleAddress)
          | crowdsaleInstance.beneficiary.call()
          | crowdsaleInstance.amountRaised.call()
          | crowdsaleInstance.fundingGoal.call()


        p You are now set. Anyone can now contribute by simply sending ether to the crowdsale address, but to make it even simpler, let's register a name for your sale. First, pick a name for your crowdsale:


        code var name = "mycrowdsale"


        p Check if that's available and register:


        code registrar.addr(name) 
          | registrar.reserve.sendTransaction(name, {from: eth.accounts[0]});
         
        p Wait for the previous transaction to be picked up and then:


        code registrar.setAddress.sendTransaction(name, crowdsaleAddress, true,{from: eth.accounts[0]});


        p Now anyone can contribute to it by simply executing this command: 


        code var amount = web3.toWei(4, "ether") // decide how much to contribute
          | eth.sendTransaction({from: eth.accounts[0], to: registrar.addr("mycrowdsale"), value: amount, gas:1000000, gasPrice:web3.toWei(0.001, "finney") })


        p Now wait a minute for the blocks to pickup and you can check if the contract received the ether by doing this: 


        code eth.getBalance(crowdsaleAddress);


        p If the balance has changed, use now this to check if you received tokens


        code tokenInstance.balance.call(eth.accounts[0])




        p This allows anyone to simply send ether to the contract, but others might want to interact more deeply with it, for example they may want to build a service that regularly checks the progress of the crowdfund, or to inspect who are it's funders. In order to do that, one has to instantiate the contract by doing this:


        code crowdsaleInstance = eth.contract([{inputs:[],name:'checkGoalReached',outputs:[{name:'response',type:'bytes32'}],type:'function',constant:false},{inputs:[],name:'deadline',outputs:[{name:'',type:'uint256'}],type:'function',constant:true},{inputs:[],name:'beneficiary',outputs:[{name:'',type:'address'}],type:'function',constant:true},{outputs:[{name:'response',type:'bytes32'}],type:'function',constant:false,inputs:[{name:'_beneficiary',type:'address'},{name:'_fundingGoal',type:'uint256'},{name:'_deadline',type:'uint256'},{name:'_price',type:'uint256'},{name:'_reward',type:'address'}],name:'setup'},{constant:true,inputs:[],name:'tokenReward',outputs:[{name:'',type:'address'}],type:'function'},{constant:true,inputs:[],name:'fundingGoal',outputs:[{type:'uint256',name:''}],type:'function'},{inputs:[],name:'price',outputs:[{type:'uint256',name:''}],type:'function',constant:true},{constant:true,inputs:[],name:'amountRaised',outputs:[{name:'',type:'uint256'}],type:'function'},{constant:true,inputs:[],name:'numFunders',outputs:[{name:'',type:'uint256'}],type:'function'},{inputs:[{name:'',type:'uint256'}],name:'funders',outputs:[{name:'addr',type:'address'},{name:'amount',type:'uint256'}],type:'function',constant:true},{inputs:[],name:'admin',outputs:[{name:'',type:'address'}],type:'function',constant:true},{inputs:[],type:'constructor'}]).at(registrar.addr('mycrowdsale'))


        p Tip: check the section on how to register your token ABI on the last chapter on how to upload the abi on the network so all the user needs is the name or address of the contract.


        p Once instantiated, anyone can check the progress of the contract by calling one of it's functions, like this:


        code "The current funding at " +( 100 *  crowdsaleInstance.amountRaised.call() / crowdsaleInstance.fundingGoal.call()) + "% of its goals. Currently, " + crowdsaleInstance.numFunders.call() + " funders have contributed a total of " + web3.fromWei(crowdsaleInstance.amountRaised.call(), "ether") + " ether. The deadline is at " + Date(crowdsaleInstance.deadline.call())

        p Once the deadline is passed someone has to wake up the contract to have the funds sent to either the beneficiary or back to the funders (if it failed). This happens because there is no such thing as an active loop or timer on ethereum so any future transactions must be pinged by someone.


        code crowdsaleInstance.checkGoalReached.sendTransaction({from:eth.accounts[1], gas: 1000000, gasPrice:web3.toWei(0.001, "finney")})


        h3 A decentralized autonomous organization: 
          strong the Democracy Contract
        
        p So far you created a tradeable token and you successfully distributed it among all those who were willing to help fundraise a 100 ethers. That's all very interesting but what exactly are those tokens for?  Why would anyone want to own or trade it for anything else valuable? If you can convince your new token is the next big money maybe others will want it, but so far your token offers no value per se. We are going to change that, by creating your first decentralized autonomous organization, or DAO.


        p Think of the DAO as the constitution of your country, the executive branch of it's government or maybe like a completely robotic middle manager for an organization. The DAO receives the money that your organization raises via any means, keeps it safe and uses it to fund whatever it's citizens want. The robot is incorruptible, it will never defraud the bank, never create secret plans, never use the money for anything other than what it's constituents voted on. The DAO will never disappear, never run away and cannot be controlled by anyone other than it's own citizens.


        p The token we created using the crowdsale is the only citizen document needed. Anyone who holds any token is able to create and vote on proposals. Similar to being a shareholder in a company, the token can be traded on the open market and the vote is proportional to amounts of tokens the voter holds.  


        p Take a moment to dream about the revolutionary possibilities this would allow, and now you can do it yourself, in under a 100 lines of code:


        code contract token { mapping (address => uint) public balances;   function token() { }   function sendToken(address receiver, uint amount) returns(bool sufficient) {  } }
          |    contract Democracy {
          |        
          |        uint public minimumQuorum = 10;
          |        uint public debatingPeriod = 7 days;
          |        token voterShare;
          |        uint public numProposals = 0;
          |        address public founder;
          |        
          |        mapping (uint => Proposal) public proposals;
          |                
          |        struct Proposal {
          |                address recipient;
          |                uint amount;
          |                bytes32 data;
          |                bytes32 descriptionHash;
          |                uint creationDate;
          |                uint numVotes;
          |                uint quorum;
          |                bool active;
          |                mapping (uint => Vote) votes;
          |                mapping (address => bool) voted;
          |        }
          |        
          |        struct Vote {
          |                int position;
          |                address voter;
          |        }
          |        
          |        function Democracy() {
          |                founder = msg.sender;        
          |        }
          |        
          |        function setup(address _voterShareAddress){
          |                if (msg.sender == founder && numProposals == 0) {
          |                        voterShare = token(_voterShareAddress);
          |                }                
          |        }
          |        
          |        function newProposal(address _recipient, uint _amount, bytes32 _data, bytes32 _descriptionHash) returns (uint proposalID) {
          |                if (voterShare.balances(msg.sender)>0) {
          |                        proposalID = numProposals++;
          |                        Proposal p = proposals[proposalID];
          |                        p.recipient = _recipient;
          |                        p.amount = _amount;
          |                        p.data = _data;
          |                        p.descriptionHash = _descriptionHash;
          |                        p.creationDate = now;
          |                        p.numVotes = 0;        
          |                        p.active = true;
          |                } else {
          |                        return 0;
          |                }
          |        }
          |        
          |        function vote(uint _proposalID, int _position) returns (uint voteID){
          |                if (voterShare.balances(msg.sender)>0 && (_position >= -1 || _position <= 1 )) {
          |                        Proposal p = proposals[_proposalID];
          |                        if (!p.voted[msg.sender]) {
          |                                voteID = p.numVotes++;
          |                                Vote v = p.votes[voteID];
          |                                v.position = _position;
          |                                v.voter = msg.sender;        
          |                                p.voted[msg.sender] = true;
          |                        }
          |                } else {
          |                        return 0;
          |                }
          |        }
          |        
          |        function executeProposal(uint _proposalID) returns (uint result) {
          |                Proposal p = proposals[_proposalID];
          |                /* Check if debating period is over */
          |                if (now > p.creationDate + debatingPeriod && p.active){                
          |                        uint yea = 0;
          |                        uint nay = 0;
          |                        /* tally the votes */
          |                        for (uint i = 0; i <=  p.numVotes; i++) {
          |                                Vote v = p.votes[i];
          |                                uint voteWeight = voterShare.balances(v.voter); 
          |                                p.quorum += voteWeight;
          |                                if (v.position > 0) {
          |                                        yea += voteWeight;
          |                                } if (v.position < 0) {
          |                                        nay += voteWeight;
          |                                }
          |                        }
          |                        /* execute result */
          |                        if (p.quorum > minimumQuorum && yea > nay ) {
          |                                p.recipient.call.value(p.amount)(p.data);
          |                                p.active = false;
          |                        } else if (p.quorum > minimumQuorum && nay > yea) {
          |                                p.active = false;
          |                        }
          |                        return yea - nay;
          |                }
          |        }
          | }

        p There's a lot of going on but if you have ever read any kind of code this one should be easily understandable. The rules of your country are very simple: anyone with at least one token can create proposals to send funds from the country's account. After a week of debate and votes, if it has received votes totally at least 100 tokens and has more approvals than rejections, the funds will be sent. If the quorum hasn't been met or it ends on a tie, then voting is kept until it's resolved. Otherwise, the proposal is locked and kept for historical purposes.


        p So let's recap what this means: in the last two sections you created 10,000 tokens, sent 1,000 of those to another account you control, 2,000 to a friend named Alice and distributed 5,000 of them via a crowdsale.  This means that you no longer control over 50% of the votes in the DAO, and if Alice and the community bands together, they can outvote any spending decision on the 100 ethers raised so far. This is exactly how a democracy should work. If you don't want to be a part of your country anymore the only thing you can do is sell your own tokens on a decentralized exchange and opt out, but you cannot prevent the others from doing so.


        p So open your console and let's get ready to finally put your country online:


        code var daoSource = 'contract token { mapping (address => uint) public balances; function token() { } function sendToken(address receiver, uint amount) returns(bool sufficient) { } } contract Democracy { uint public minimumQuorum = 10; uint public debatingPeriod = 7 days; token voterShare; uint public numProposals = 0; address public founder; mapping (uint => Proposal) public proposals; struct Proposal { address recipient; uint amount; bytes32 data; bytes32 descriptionHash; uint creationDate; uint numVotes; uint quorum; bool active; mapping (uint => Vote) votes; mapping (address => bool) voted; } struct Vote { int position; address voter; } function Democracy() { founder = msg.sender; } function setup(address _voterShareAddress){ if (msg.sender == founder && numProposals == 0) { voterShare = token(_voterShareAddress); } } function newProposal(address _recipient, uint _amount, bytes32 _data, bytes32 _descriptionHash) returns (uint proposalID) { if (voterShare.balances(msg.sender)>0) { proposalID = numProposals++; Proposal p = proposals[proposalID]; p.recipient = _recipient; p.amount = _amount; p.data = _data; p.descriptionHash = _descriptionHash; p.creationDate = now; p.numVotes = 0; p.active = true; } else { return 0; } } function vote(uint _proposalID, int _position) returns (uint voteID){ if (voterShare.balances(msg.sender)>0 && (_position >= -1 || _position <= 1 )) { Proposal p = proposals[_proposalID]; if (!p.voted[msg.sender]) { voteID = p.numVotes++; Vote v = p.votes[voteID]; v.position = _position; v.voter = msg.sender; p.voted[msg.sender] = true; } } else { return 0; } } function executeProposal(uint _proposalID) returns (uint result) { Proposal p = proposals[_proposalID]; /* Check if debating period is over */ if (now > p.creationDate + debatingPeriod && p.active){ uint yea = 0; uint nay = 0; /* tally the votes */ for (uint i = 0; i <= p.numVotes; i++) { Vote v = p.votes[i]; uint voteWeight = voterShare.balances(v.voter); p.quorum += voteWeight; if (v.position > 0) { yea += voteWeight; } if (v.position < 0) { nay += voteWeight; } } /* execute result */ if (p.quorum > minimumQuorum && yea > nay ) { p.recipient.call.value(p.amount)(p.data); p.active = false; } else if (p.quorum > minimumQuorum && nay > yea) { p.active = false; } return yea - nay; } } }'
         | var daoCompiled = eth.compile.solidity(daoSource);
         | var daoAddress = eth.sendTransaction({data: daoCompiled.Democracy.code, from: eth.accounts[0], gas:1000000, gasPrice: web3.toWei(0.001, "finney")});


        p Wait a minute until the miners pick it up. It will cost you about 0.6 ethers in current market price. Once it's picked up it's time to instantiate it and set it up, by pointing it to the correct address of the token contract you created previously. Let's also register a name for your contract so it's easily accessible (don't forget to check your name availability with registrar.addr("nameYouWant") before reserving!)


        code var name = "MyPersonalCountry"
         | registrar.reserve.sendTransaction(name, {from: eth.accounts[0]})
         | var daoInstance = eth.contract(daoCompiled.Democracy.info.abiDefinition).at(daoAddress);
         | daoInstance.setup.sendTransaction(registrar.addr("MyFirstCoin"),{from:eth.accounts[0]})


        p Wait for the previous transactions to be picked up and then:


        code registrar.setAddress.sendTransaction(name, daoAddress, true,{from: eth.accounts[0]});


        p Test the parameters by doing these commands:


        code daoInstance.numProposals.call();
         | daoInstance.proposals.call();
         | daoInstance.founder.call()



        p If everything is setup then your DAO should return a proposal count of 0 and an address marked as the "founder". While there are still no proposals, the founder of the DAO can change the address of the token to anything it wants. After you are satisfied with what you want, it's time to get all that ether you got from the crowdfunding and into your new country:


        code eth.sendTransaction({from: eth.accounts[1], to: daoAddress, value: web3.toWei(100, "ether")})


        p This should take only a minute and your country is ready for business! Now, as a first priority, your country needs a nice flag, but unless you are a flag expert, you have no idea how to do that. For the sake of argument let's say you find that your friend Bob is a great flag designer who's willing to do it for only 10 ethers, so you want to propose to hire him to design a flag. 


        code recipient = registrar.addr("bob");
         | amount =  web3.toWei(10, "ether");
         | shortNote = "Flag Design";
         | daoInstance.newProposal.sendTransaction( recipient, amount, shortNote, '', {from: eth.accounts[0], gas:1000000, gasPrice: web3.toWei(0.001, "finney")})


        p After a minute, anyone can check the proposal recipient and amount by executing these commands:


        code daoInstance.numProposals.call()


        p Unlike most governments, your country's government is completely transparent and easily programmable. As a small demonstration here's a snippet of code that goes through all the current proposals and prints what they are and for whom:


        code function checkAllProposals() {  
          |   for (i = 0; i< daoInstance.numProposals.call(); i++ ) { 
          |     var p = daoInstance.proposals.call(i)
          |       console.log("Proposal #" + i + "         Send " + web3.fromWei( p[1], "ether") + " ether to address " + p[0] + " for " + p[2]); 
          |   }
          | }
          | checkAllProposals();


        p A concerned citizen could easily write a bot that periodically pings the blockchain and then publicizes any new proposals that were put forth, guaranteeing total transparency.


        p Now of course you want other people to be able to vote on your proposals. You can check the crowdsale tutorial on the best way to register your contract app so that all the user needs is a name, but for now let's use the easier version. Anyone should be able to instantiate a local copy of your country in their computer by using this giant command: 




        code daoInstance = eth.contract([{outputs:[{name:'recipient',type:'address'},{name:'amount',type:'uint256'},{name:'data',type:'bytes32'},{name:'descriptionHash',type:'bytes32'},{name:'creationDate',type:'uint256'},{name:'numVotes',type:'uint256'},{name:'quorum',type:'uint256'},{name:'active',type:'bool'}],type:'function',constant:true,inputs:[{name:'',type:'uint256'}],name:'proposals'},{constant:false,inputs:[{type:'uint256',name:'_proposalID'}],name:'executeProposal',outputs:[{name:'result',type:'uint256'}],type:'function'},{constant:true,inputs:[],name:'debatingPeriod',outputs:[{name:'',type:'uint256'}],type:'function'},{constant:true,inputs:[],name:'numProposals',outputs:[{name:'',type:'uint256'}],type:'function'},{name:'founder',outputs:[{name:'',type:'address'}],type:'function',constant:true,inputs:[]},{constant:false,inputs:[{type:'uint256',name:'_proposalID'},{name:'_position',type:'int256'}],name:'vote',outputs:[{name:'voteID',type:'uint256'}],type:'function'},{outputs:[],type:'function',constant:false,inputs:[{name:'_voterShareAddress',type:'address'}],name:'setup'},{type:'function',constant:false,inputs:[{type:'address',name:'_recipient'},{name:'_amount',type:'uint256'},{name:'_data',type:'bytes32'},{name:'_descriptionHash',type:'bytes32'}],name:'newProposal',outputs:[{name:'proposalID',type:'uint256'}]},{type:'function',constant:true,inputs:[],name:'minimumQuorum',outputs:[{name:'',type:'uint256'}]},{inputs:[],type:'constructor'}]},{type:'constructor',inputs:[]}]).at(registrar.addr('MyPersonalCountry'))


        p Then anyone who owns any of your tokens can vote on the proposals by doing this:


        code var proposalID = 0;
          | var position = 1; // +1 for voting yea, -1 for voting nay, 0 abstains but counts as quorum
          | daoInstance.vote.sendTransaction(proposalID, position, {from: eth.accounts[0]});




        p Unless you changed the basic parameters in the code, any proposal will have to be debated for at least a week until it can be executed. After that anyone—even a non-citizen—can demand the votes to be counted and the proposal to be executed. The votes are tallied and weighted at that moment and if the proposal is accepted then the ether is sent immediately and the proposal. If the votes end in a tie or the minimum quorum hasn’t been reached, the voting is kept open until the stalemate is resolved. If it loses, then it's archived and cannot be voted again.


        code var proposalID = 0;
          | daoInstance.executeProposal.sendTransaction(proposalID, {from: eth.accounts[0]});




        p If the proposal passed then you should be able to see Bob's ethers arriving on his address:


        code eth.getBalance(registrar.addr("bob"));




        p Try for yourself:  This is a very simple democracy contract, which could be vastly improved: currently, all proposals have the same debating time and are won by direct vote and simple majority.  Can you change that so it will have some situations, depending on the amount proposed, that the debate might be longer or that it would require a larger majority? Also think about some way where citizens didn't need to vote on every issue and could temporarily delegate their votes to a special representative. You might have also noticed that we added a tiny description for each proposal. This could be used as a title for the proposal or could be a hash of a larger document describing it in detail.


        h3 Let's go exploring!


        p You have reached the end of this tutorial, but it's just the beginning of a great adventure. Look back and see how much you accomplished: you created a living, talking robot, your own cryptocurrency, raised funds through a trustless crowdfunding and used it to kickstart your own personal country. 


        p For the sake of simplicity, the simple democratic organization you created can only send ether around, the native currency of ethereum. While that might be good enough for some, this is only scratching the surface of what can be done. In the ethereum network contracts have all the same rights as any normal user, meaning that your organization could be programmed in such way that it could do any of the transactions that you executed coming from your own accounts. 


        p What could happen next?

        ol
          li The greeter contract you created at the beginning could be improved to charge ether for its services and could funnel those funds into the DAO.
          li The tokens you still control could be sold on a decentralized exchange or traded for goods and services to fund further develop the first contract and grow the organization.
          li Your DAO could own it's own name on the name registrar, and then change where it's redirecting in order to update itself if the token holders approved.
          li The organization could hold not only ethers, but any kind of other coin created on ethereum, including assets whose value are tied to the bitcoin or dollar. 
          li The DAO could be programmed to allow a proposal with multiple transactions, some scheduled to the future. 
          li It could also own shares of other DAO's, meaning it could vote on larger organization or be a part of a federation of DAO's
          li The Token Contract could be reprogrammed to hold ether or to hold other tokens and distribute it to the token holders, linking therefore the value of the token to the value of other assets, so paying dividends could be accomplished by simply moving funds to the token address


        p This all means that this tiny society you created could grow, get funding from third parties, pay recurrent salaries, own any kind of cryptoassets and even use crowdsales to fund its activities. All with full transparency, complete accountability and complete immunity from any human interference. While the network lives the contracts will execute exactly the code they were created to execute, without any exception, forever.


        p So what will your contract be? Will it be a country, a company, a non-profit group? What will your code do? 


        p That's up to you.


        h4 Next Steps
         
        p You accomplished a lot today, you should feel proud. But if you are still thirsty for knowledge, here are some cool projects that are live and you can participate in:

        ol
          li Etherex
          li Augur
          li eDollar
          li Reddit flair manager (suggestion: basic contract where users can request “frontier” flairs in the subreddit)
          li etc..




  div.footer
    div.container

      div.row
        div.col-md-6
          h2 Supported platforms
          p We currently support Mac OS X and Linux. For more information about installing and building go-ethereum on other platforms please visit our #[a(target="_blank", href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum(Go)") wiki page].

        div.col-md-6
          h2 Troubleshooting
          p If something went wrong first read our Troubleshooting checklist. If you still didn't find your answer please #[a(href="") open an issue on GitHub] or contact our #[a(href="#") help desk].

      div.clearfix
        br
        br

      div.row
        div.col-md-6
          h2 Security
          p Please report security issues to #[a(href="mailto:security@ethereum.org") security@ethereum.org].

        div.col-md-6
          h2 License
          p Ethereum Core Protocol licensed under the #[a(target="_blank", href="https://github.com/ethereum/go-ethereum/blob/develop/LICENSE") GNU Lesser General Public License]. Ethereum client licensed under the GPL.

      div.clearfix
        br
        br